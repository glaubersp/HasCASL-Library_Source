theory Prelude_Ord
imports "$HETS_ISABELLE_LIB/MainHC"
uses "$HETS_ISABELLE_LIB/prelude"
begin

setup "Header.initialize
       [\"NotFalse\", \"NotTrue\", \"AndFalse\", \"AndTrue\", \"AndSym\",
        \"OrDef\", \"OtherwiseDef\", \"NotFalse1\", \"NotTrue1\",
        \"notNot1\", \"notNot2\", \"EqualTDef\", \"EqualSymDef\",
        \"EqualReflex\", \"EqualTransT\", \"DiffDef\", \"DiffSymDef\",
        \"DiffTDef\", \"DiffFDef\", \"TE1\", \"TE2\", \"TE3\", \"TE4\",
        \"IBE1\", \"IBE2\", \"IBE3\", \"IBE4\", \"IBE5\", \"IBE6\",
        \"IBE7\", \"IBE8\", \"IUE1\", \"IUE2\", \"IOE04\", \"IOE05\",
        \"IOE06\", \"LeIrreflexivity\", \"LeTTransitive\", \"LeTTotal\",
        \"GeDef\", \"LeqDef\", \"GeqDef\", \"EqTSOrdRel\", \"EqFSOrdRel\",
        \"EqTOrdRel\", \"EqFOrdRel\", \"EqTOrdTSubstE\", \"EqTOrdFSubstE\",
        \"EqTOrdTSubstD\", \"EqTOrdFSubstD\", \"LeTGeFEqFRel\",
        \"LeFGeTEqTRel\", \"CmpLTDef\", \"CmpEQDef\", \"CmpGTDef\",
        \"MaxYDef\", \"MaxXDef\", \"MinXDef\", \"MinYDef\", \"IOO13\",
        \"IOO14\", \"IOO15\", \"IBO5\", \"IOE01\", \"IOE02\", \"IOE03\",
        \"IOE07\", \"IOE08\", \"IOE09\", \"LeTAsymmetry\",
        \"GeIrreflexivity\", \"GeTAsymmetry\", \"GeTTransitive\",
        \"GeTTotal\", \"LeqReflexivity\", \"LeqTTransitive\",
        \"LeqTTotal\", \"GeqReflexivity\", \"GeqTTransitive\",
        \"GeqTTotal\", \"LeTGeTRel\", \"LeFGeFRel\", \"LeqTGetTRel\",
        \"LeqFGetFRel\", \"GeTLeTRel\", \"GeFLeFRel\", \"GeqTLeqTRel\",
        \"GeqFLeqFRel\", \"LeqTGeFRel\", \"LeqFGeTRel\", \"GeTLeFEqFRel\",
        \"GeFLeTEqTRel\", \"GeqTLeFRel\", \"GeqFLeTRel\",
        \"LeqTLeTEqTRel\", \"LeqFLeFEqFRel\", \"GeqTGeTEqTRel\",
        \"GeqFGeFEqFRel\", \"LeTGeqFRel\", \"GeTLeqFRel\", \"LeLeqDiff\",
        \"MaxSym\", \"MinSym\", \"TO1\", \"TO3\", \"TO4\", \"TO5\",
        \"IOO16\", \"IOO17\", \"IOO18\", \"IOO19\", \"IOO20\", \"IOO21\",
        \"IOO22\", \"IOO23\", \"IOO24\", \"IOO25\", \"IOO26\", \"IOO27\",
        \"IOO28\", \"IOO29\", \"IOO30\", \"IOO31\", \"IOO32\", \"IOO33\",
        \"IBO6\", \"IBO7\", \"IBO8\", \"IBO9\", \"IBO10\", \"IBO11\",
        \"IBO12\", \"IUO01\", \"IUO02\", \"IUO03\", \"IUO04\", \"IUO05\",
        \"IUO06\", \"IUO07\"]"

typedecl Unit

datatype Bool = X_False ("False''") | X_True ("True''")
datatype Ordering = EQ | GT | LT

consts
X__XAmpXAmp__X :: "Bool => Bool => Bool" ("(_/ &&/ _)" [54,54] 52)
X__XEqXEq__X :: "'a => 'a => Bool" ("(_/ ==''/ _)" [54,54] 52)
X__XGtXEq__X :: "'a => 'a => Bool" ("(_/ >=''/ _)" [54,54] 52)
X__XGt__X :: "'a => 'a => Bool" ("(_/ >''/ _)" [54,54] 52)
X__XLtXEq__X :: "'a => 'a => Bool" ("(_/ <=''/ _)" [54,54] 52)
X__XLt__X :: "'a => 'a => Bool" ("(_/ <''/ _)" [54,54] 52)
X__XSlashXEq__X :: "'a => 'a => Bool" ("(_/ '/=/ _)" [54,54] 52)
X__XVBarXVBar__X :: "Bool => Bool => Bool" ("(_/ ||/ _)" [54,54] 52)
X_max :: "'a => 'a => 'a"
X_min :: "'a => 'a => 'a"
compare :: "'a => 'a => Ordering"
notH__X :: "Bool => Bool" ("(notH/ _)" [56] 56)
otherwiseH :: "Bool"

axioms
NotFalse [rule_format] : "notH False' = True'"

NotTrue [rule_format] : "notH True' = False'"

AndFalse [rule_format] : "ALL (x :: Bool). False' && x = False'"

AndTrue [rule_format] : "ALL (x :: Bool). True' && x = x"

AndSym [rule_format] :
"ALL (x :: Bool). ALL (y :: Bool). x && y = y && x"

OrDef [rule_format] :
"ALL (x :: Bool).
 ALL (y :: Bool). x || y = notH (notH x && notH y)"

OtherwiseDef [rule_format] : "otherwiseH = True'"

NotFalse1 [rule_format] :
"ALL (x :: Bool). notH x = True' = (x = False')"

NotTrue1 [rule_format] :
"ALL (x :: Bool). notH x = False' = (x = True')"

notNot1 [rule_format] :
"ALL (x :: Bool). (~ x = True') = (notH x = True')"

notNot2 [rule_format] :
"ALL (x :: Bool). (~ x = False') = (notH x = False')"

EqualTDef [rule_format] :
"ALL (x :: 'a). ALL (y :: 'a). x = y --> x ==' y = True'"

EqualSymDef [rule_format] :
"ALL (x :: 'a). ALL (y :: 'a). x ==' y = y ==' x"

EqualReflex [rule_format] : "ALL (x :: 'a). x ==' x = True'"

EqualTransT [rule_format] :
"ALL (x :: 'a).
 ALL (y :: 'a).
 ALL (z :: 'a).
 x ==' y = True' & y ==' z = True' --> x ==' z = True'"

DiffDef [rule_format] :
"ALL (x :: 'a). ALL (y :: 'a). x /= y = notH (x ==' y)"

DiffSymDef [rule_format] :
"ALL (x :: 'a). ALL (y :: 'a). x /= y = y /= x"

DiffTDef [rule_format] :
"ALL (x :: 'a).
 ALL (y :: 'a). x /= y = True' = (notH (x ==' y) = True')"

DiffFDef [rule_format] :
"ALL (x :: 'a). ALL (y :: 'a). x /= y = False' = (x ==' y = True')"

TE1 [rule_format] :
"ALL (x :: 'a). ALL (y :: 'a). x ==' y = False' --> ~ x = y"

TE2 [rule_format] :
"ALL (x :: 'a).
 ALL (y :: 'a). notH (x ==' y) = True' = (x ==' y = False')"

TE3 [rule_format] :
"ALL (x :: 'a).
 ALL (y :: 'a). notH (x ==' y) = False' = (x ==' y = True')"

TE4 [rule_format] :
"ALL (x :: 'a).
 ALL (y :: 'a). (~ x ==' y = True') = (x ==' y = False')"

IBE1 [rule_format] : "True' ==' True' = True'"

IBE2 [rule_format] : "False' ==' False' = True'"

IBE3 [rule_format] : "False' ==' True' = False'"

IBE4 [rule_format] : "True' ==' False' = False'"

IBE5 [rule_format] : "True' /= False' = True'"

IBE6 [rule_format] : "False' /= True' = True'"

IBE7 [rule_format] : "notH (True' ==' False') = True'"

IBE8 [rule_format] : "notH notH (True' ==' False') = False'"

IUE1 [rule_format] : "() ==' () = True'"

IUE2 [rule_format] : "() /= () = False'"

IOE04 [rule_format] : "LT ==' EQ = False'"

IOE05 [rule_format] : "LT ==' GT = False'"

IOE06 [rule_format] : "EQ ==' GT = False'"

LeIrreflexivity [rule_format] :
"ALL (x :: 'a). ALL (y :: 'a). x ==' y = True' --> x <' y = False'"

LeTTransitive [rule_format] :
"ALL (x :: 'a).
 ALL (y :: 'a).
 ALL (z :: 'a). x <' y = True' & y <' z = True' --> x <' z = True'"

LeTTotal [rule_format] :
"ALL (x :: 'a).
 ALL (y :: 'a). (x <' y = True' | y <' x = True') | x ==' y = True'"

GeDef [rule_format] :
"ALL (x :: 'a). ALL (y :: 'a). x >' y = y <' x"

LeqDef [rule_format] :
"ALL (x :: 'a). ALL (y :: 'a). x <=' y = (x <' y) || (x ==' y)"

GeqDef [rule_format] :
"ALL (x :: 'a). ALL (y :: 'a). x >=' y = (x >' y) || (x ==' y)"

EqTSOrdRel [rule_format] :
"ALL (x :: 'a).
 ALL (y :: 'a).
 x ==' y = True' = (x <' y = False' & x >' y = False')"

EqFSOrdRel [rule_format] :
"ALL (x :: 'a).
 ALL (y :: 'a).
 x ==' y = False' = (x <' y = True' | x >' y = True')"

EqTOrdRel [rule_format] :
"ALL (x :: 'a).
 ALL (y :: 'a).
 x ==' y = True' = (x <=' y = True' & x >=' y = True')"

EqFOrdRel [rule_format] :
"ALL (x :: 'a).
 ALL (y :: 'a).
 x ==' y = False' = (x <=' y = True' | x >=' y = True')"

EqTOrdTSubstE [rule_format] :
"ALL (x :: 'a).
 ALL (y :: 'a).
 ALL (z :: 'a). x ==' y = True' & y <' z = True' --> x <' z = True'"

EqTOrdFSubstE [rule_format] :
"ALL (x :: 'a).
 ALL (y :: 'a).
 ALL (z :: 'a).
 x ==' y = True' & y <' z = False' --> x <' z = False'"

EqTOrdTSubstD [rule_format] :
"ALL (x :: 'a).
 ALL (y :: 'a).
 ALL (z :: 'a). x ==' y = True' & z <' y = True' --> z <' x = True'"

EqTOrdFSubstD [rule_format] :
"ALL (x :: 'a).
 ALL (y :: 'a).
 ALL (z :: 'a).
 x ==' y = True' & z <' y = False' --> z <' x = False'"

LeTGeFEqFRel [rule_format] :
"ALL (x :: 'a).
 ALL (y :: 'a).
 x <' y = True' = (x >' y = False' & x ==' y = False')"

LeFGeTEqTRel [rule_format] :
"ALL (x :: 'a).
 ALL (y :: 'a).
 x <' y = False' = (x >' y = True' | x ==' y = True')"

CmpLTDef [rule_format] :
"ALL (x :: 'a). ALL (y :: 'a). compare x y ==' LT = x <' y"

CmpEQDef [rule_format] :
"ALL (x :: 'a). ALL (y :: 'a). compare x y ==' EQ = x ==' y"

CmpGTDef [rule_format] :
"ALL (x :: 'a). ALL (y :: 'a). compare x y ==' GT = x >' y"

MaxYDef [rule_format] :
"ALL (x :: 'a). ALL (y :: 'a). X_max x y ==' y = x <=' y"

MaxXDef [rule_format] :
"ALL (x :: 'a). ALL (y :: 'a). X_max x y ==' x = y <=' x"

MinXDef [rule_format] :
"ALL (x :: 'a). ALL (y :: 'a). X_min x y ==' x = x <=' y"

MinYDef [rule_format] :
"ALL (x :: 'a). ALL (y :: 'a). X_min x y ==' y = y <=' x"

IOO13 [rule_format] : "LT <' EQ = True'"

IOO14 [rule_format] : "EQ <' GT = True'"

IOO15 [rule_format] : "LT <' GT = True'"

IBO5 [rule_format] : "False' <' True' = True'"

declare NotFalse [simp]
declare NotTrue [simp]
declare AndFalse [simp]
declare AndTrue [simp]
declare EqualReflex [simp]
declare IBE1 [simp]
declare IBE2 [simp]
declare IBE3 [simp]
declare IBE4 [simp]
declare IBE5 [simp]
declare IBE6 [simp]
declare IBE7 [simp]
declare IBE8 [simp]
declare IOE04 [simp]
declare IOE05 [simp]
declare IOE06 [simp]
declare LeIrreflexivity [simp]
declare CmpLTDef [simp]
declare CmpEQDef [simp]
declare CmpGTDef [simp]
declare MaxYDef [simp]
declare MaxXDef [simp]
declare MinXDef [simp]
declare MinYDef [simp]
declare IOO13 [simp]
declare IOO14 [simp]
declare IOO15 [simp]
declare IBO5 [simp]

theorem IOE01 : "LT ==' LT = True'"
by (auto)

setup "Header.record \"IOE01\""

theorem IOE02 : "EQ ==' EQ = True'"
by (auto)

setup "Header.record \"IOE02\""

theorem IOE03 : "GT ==' GT = True'"
by (auto)

setup "Header.record \"IOE03\""

theorem IOE07 : "LT /= EQ = True'"
by (auto)

setup "Header.record \"IOE07\""

theorem IOE08 : "LT /= GT = True'"
by (auto)

setup "Header.record \"IOE08\""

theorem IOE09 : "EQ /= GT = True'"
by (auto)

setup "Header.record \"IOE09\""

theorem LeTAsymmetry :
"ALL (x :: 'a). ALL (y :: 'a). x <' y = True' --> y <' x = False'"
by (auto)

setup "Header.record \"LeTAsymmetry\""

theorem GeIrreflexivity :
"ALL (x :: 'a). ALL (y :: 'a). x ==' y = True' --> x >' y = False'"
by (auto)

setup "Header.record \"GeIrreflexivity\""

theorem GeTAsymmetry :
"ALL (x :: 'a). ALL (y :: 'a). x >' y = True' --> y >' x = False'"
by (auto)

setup "Header.record \"GeTAsymmetry\""

theorem GeTTransitive :
"ALL (x :: 'a).
 ALL (y :: 'a).
 ALL (z :: 'a). (x >' y) && (y >' z) = True' --> x >' z = True'"
by (auto)

setup "Header.record \"GeTTransitive\""

theorem GeTTotal :
"ALL (x :: 'a).
 ALL (y :: 'a). ((x >' y) || (y >' x)) || (x ==' y) = True'"
by (auto)

setup "Header.record \"GeTTotal\""

theorem LeqReflexivity : "ALL (x :: 'a). x <=' x = True'"
by (auto)

setup "Header.record \"LeqReflexivity\""

theorem LeqTTransitive :
"ALL (x :: 'a).
 ALL (y :: 'a).
 ALL (z :: 'a). (x <=' y) && (y <=' z) = True' --> x <=' z = True'"
by (auto)

setup "Header.record \"LeqTTransitive\""

theorem LeqTTotal :
"ALL (x :: 'a). ALL (y :: 'a). (x <=' y) && (y <=' x) = x ==' y"
by (auto)

setup "Header.record \"LeqTTotal\""

theorem GeqReflexivity : "ALL (x :: 'a). x >=' x = True'"
by (auto)

setup "Header.record \"GeqReflexivity\""

theorem GeqTTransitive :
"ALL (x :: 'a).
 ALL (y :: 'a).
 ALL (z :: 'a). (x >=' y) && (y >=' z) = True' --> x >=' z = True'"
by (auto)

setup "Header.record \"GeqTTransitive\""

theorem GeqTTotal :
"ALL (x :: 'a). ALL (y :: 'a). (x >=' y) && (y >=' x) = x ==' y"
by (auto)

setup "Header.record \"GeqTTotal\""

theorem LeTGeTRel :
"ALL (x :: 'a). ALL (y :: 'a). x <' y = True' = (y >' x = True')"
by (auto)

setup "Header.record \"LeTGeTRel\""

theorem LeFGeFRel :
"ALL (x :: 'a). ALL (y :: 'a). x <' y = False' = (y >' x = False')"
by (auto)

setup "Header.record \"LeFGeFRel\""

theorem LeqTGetTRel :
"ALL (x :: 'a). ALL (y :: 'a). x <=' y = True' = (y >=' x = True')"
by (auto)

setup "Header.record \"LeqTGetTRel\""

theorem LeqFGetFRel :
"ALL (x :: 'a).
 ALL (y :: 'a). x <=' y = False' = (y >=' x = False')"
by (auto)

setup "Header.record \"LeqFGetFRel\""

theorem GeTLeTRel :
"ALL (x :: 'a). ALL (y :: 'a). x >' y = True' = (y <' x = True')"
by (auto)

setup "Header.record \"GeTLeTRel\""

theorem GeFLeFRel :
"ALL (x :: 'a). ALL (y :: 'a). x >' y = False' = (y <' x = False')"
by (auto)

setup "Header.record \"GeFLeFRel\""

theorem GeqTLeqTRel :
"ALL (x :: 'a). ALL (y :: 'a). x >=' y = True' = (y <=' x = True')"
by (auto)

setup "Header.record \"GeqTLeqTRel\""

theorem GeqFLeqFRel :
"ALL (x :: 'a).
 ALL (y :: 'a). x >=' y = False' = (y <=' x = False')"
by (auto)

setup "Header.record \"GeqFLeqFRel\""

theorem LeqTGeFRel :
"ALL (x :: 'a). ALL (y :: 'a). x <=' y = True' = (x >' y = False')"
by (auto)

setup "Header.record \"LeqTGeFRel\""

theorem LeqFGeTRel :
"ALL (x :: 'a). ALL (y :: 'a). x <=' y = False' = (x >' y = True')"
by (auto)

setup "Header.record \"LeqFGeTRel\""

theorem GeTLeFEqFRel :
"ALL (x :: 'a).
 ALL (y :: 'a).
 x >' y = True' = (x <' y = False' & x ==' y = False')"
by (auto)

setup "Header.record \"GeTLeFEqFRel\""

theorem GeFLeTEqTRel :
"ALL (x :: 'a).
 ALL (y :: 'a).
 x >' y = False' = (x <' y = True' | x ==' y = True')"
by (auto)

setup "Header.record \"GeFLeTEqTRel\""

theorem GeqTLeFRel :
"ALL (x :: 'a). ALL (y :: 'a). x >=' y = True' = (x <' y = False')"
by (auto)

setup "Header.record \"GeqTLeFRel\""

theorem GeqFLeTRel :
"ALL (x :: 'a). ALL (y :: 'a). x >=' y = False' = (x <' y = True')"
by (auto)

setup "Header.record \"GeqFLeTRel\""

theorem LeqTLeTEqTRel :
"ALL (x :: 'a).
 ALL (y :: 'a).
 x <=' y = True' = (x <' y = True' | x ==' y = True')"
by (auto)

setup "Header.record \"LeqTLeTEqTRel\""

theorem LeqFLeFEqFRel :
"ALL (x :: 'a).
 ALL (y :: 'a).
 x <=' y = False' = (x <' y = False' & x ==' y = False')"
by (auto)

setup "Header.record \"LeqFLeFEqFRel\""

theorem GeqTGeTEqTRel :
"ALL (x :: 'a).
 ALL (y :: 'a).
 x >=' y = True' = (x >' y = True' | x ==' y = True')"
by (auto)

setup "Header.record \"GeqTGeTEqTRel\""

theorem GeqFGeFEqFRel :
"ALL (x :: 'a).
 ALL (y :: 'a).
 x >=' y = False' = (x >' y = False' & x ==' y = False')"
by (auto)

setup "Header.record \"GeqFGeFEqFRel\""

theorem LeTGeqFRel :
"ALL (x :: 'a). ALL (y :: 'a). x <' y = True' = (x >=' y = False')"
by (auto)

setup "Header.record \"LeTGeqFRel\""

theorem GeTLeqFRel :
"ALL (x :: 'a). ALL (y :: 'a). x >' y = True' = (x <=' y = False')"
by (auto)

setup "Header.record \"GeTLeqFRel\""

theorem LeLeqDiff :
"ALL (x :: 'a). ALL (y :: 'a). x <' y = (x <=' y) && (x /= y)"
by (auto)

setup "Header.record \"LeLeqDiff\""

theorem MaxSym :
"ALL (x :: 'a). ALL (y :: 'a). X_max x y ==' y = X_max y x ==' y"
by (auto)

setup "Header.record \"MaxSym\""

theorem MinSym :
"ALL (x :: 'a). ALL (y :: 'a). X_min x y ==' y = X_min y x ==' y"
by (auto)

setup "Header.record \"MinSym\""

theorem TO1 :
"ALL (x :: 'a).
 ALL (y :: 'a).
 (x ==' y = True' | x <' y = True') = (x <=' y = True')"
by (auto)

setup "Header.record \"TO1\""

theorem TO3 :
"ALL (x :: 'a).
 ALL (y :: 'a). notH notH (x <' y) = True' | notH (x <' y) = True'"
by (auto)

setup "Header.record \"TO3\""

theorem TO4 :
"ALL (x :: 'a).
 ALL (y :: 'a). x <' y = True' --> notH (x ==' y) = True'"
by (auto)

setup "Header.record \"TO4\""

theorem TO5 :
"ALL (w :: 'a).
 ALL (x :: 'a).
 ALL (y :: 'a).
 ALL (z :: 'a).
 (x <' y = True' & y <' z = True') & z <' w = True' -->
 x <' w = True'"
by (auto)

setup "Header.record \"TO5\""

theorem IOO16 : "LT <=' EQ = True'"
by (auto)

setup "Header.record \"IOO16\""

theorem IOO17 : "EQ <=' GT = True'"
by (auto)

setup "Header.record \"IOO17\""

theorem IOO18 : "LT <=' GT = True'"
by (auto)

setup "Header.record \"IOO18\""

theorem IOO19 : "EQ >=' LT = True'"
by (auto)

setup "Header.record \"IOO19\""

theorem IOO20 : "GT >=' EQ = True'"
by (auto)

setup "Header.record \"IOO20\""

theorem IOO21 : "GT >=' LT = True'"
by (auto)

setup "Header.record \"IOO21\""

theorem IOO22 : "EQ >' LT = True'"
by (auto)

setup "Header.record \"IOO22\""

theorem IOO23 : "GT >' EQ = True'"
by (auto)

setup "Header.record \"IOO23\""

theorem IOO24 : "GT >' LT = True'"
by (auto)

setup "Header.record \"IOO24\""

theorem IOO25 : "X_max LT EQ ==' EQ = True'"
by (auto)

setup "Header.record \"IOO25\""

theorem IOO26 : "X_max EQ GT ==' GT = True'"
by (auto)

setup "Header.record \"IOO26\""

theorem IOO27 : "X_max LT GT ==' GT = True'"
by (auto)

setup "Header.record \"IOO27\""

theorem IOO28 : "X_min LT EQ ==' LT = True'"
by (auto)

setup "Header.record \"IOO28\""

theorem IOO29 : "X_min EQ GT ==' EQ = True'"
by (auto)

setup "Header.record \"IOO29\""

theorem IOO30 : "X_min LT GT ==' LT = True'"
by (auto)

setup "Header.record \"IOO30\""

theorem IOO31 : "compare LT LT ==' EQ = True'"
by (auto)

setup "Header.record \"IOO31\""

theorem IOO32 : "compare EQ EQ ==' EQ = True'"
by (auto)

setup "Header.record \"IOO32\""

theorem IOO33 : "compare GT GT ==' EQ = True'"
by (auto)

setup "Header.record \"IOO33\""

theorem IBO6 : "False' >=' True' = False'"
by (auto)

setup "Header.record \"IBO6\""

theorem IBO7 : "True' >=' False' = True'"
by (auto)

setup "Header.record \"IBO7\""

theorem IBO8 : "True' <' False' = False'"
by (auto)

setup "Header.record \"IBO8\""

theorem IBO9 : "X_max False' True' ==' True' = True'"
by (auto)

setup "Header.record \"IBO9\""

theorem IBO10 : "X_min False' True' ==' False' = True'"
by (auto)

setup "Header.record \"IBO10\""

theorem IBO11 : "compare True' True' ==' EQ = True'"
by (auto)

setup "Header.record \"IBO11\""

theorem IBO12 : "compare False' False' ==' EQ = True'"
by (auto)

setup "Header.record \"IBO12\""

theorem IUO01 : "() <=' () = True'"
by (auto)

setup "Header.record \"IUO01\""

theorem IUO02 : "() <' () = False'"
by (auto)

setup "Header.record \"IUO02\""

theorem IUO03 : "() >=' () = True'"
by (auto)

setup "Header.record \"IUO03\""

theorem IUO04 : "() >' () = False'"
by (auto)

setup "Header.record \"IUO04\""

theorem IUO05 : "X_max () () ==' () = True'"
by (auto)

setup "Header.record \"IUO05\""

theorem IUO06 : "X_min () () ==' () = True'"
by (auto)

setup "Header.record \"IUO06\""

theorem IUO07 : "compare () () ==' EQ = True'"
by (auto)

setup "Header.record \"IUO07\""

end
